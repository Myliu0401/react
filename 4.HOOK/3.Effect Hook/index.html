<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <div id="root"></div>
    <script>
        /* 
                  Effect Hook   吐音  亦菲可特
                     用于在函数组件中处理副作用，react规定函数一定要纯，虽然函数组件不受影响，但还是将副作用代码提到 处理副作用的Hook中，比较好。
                  
                     副作用：
                        1.ajax请求
                        2.计时器
                        3.其他的异步操作
                        4.更改真实DOM
                        5.本地存储
                        6.其他会对外部产生影响的操作
                    
                    useEffect函数 接收一个函数作为参数，接收的函数就是需要进行副作用的函数。
                       如： useEffect(()=>{...副作用})

                    
                    细节： 
                       1.副作用的回调函数的运行时间点，是在页面完成真实的UI渲染之后，因此它的执行是异步的，并且不会阻塞浏览器。
                            如：如果不是异步的，如果副作用运算太多东西，那么就会导致浏览器ui渲染太慢，跟卡顿一样。
                          
                          与类组件中componentDidMount和componentDidUpdate的区别： 
                             1. componentDidMount和componentDidUpdate 钩子是在更改真实DOM，UI还没有重新渲染，用户还没有看到更新后的UI。
                                     更新真实DOM后就立即调用对应的钩子，所以是同步的。（因为浏览器还要进行重绘）
                                更改完之后，浏览器需要进行重渲染。
                             2.useEffect的回调副作用函数，更改了真实DOM，并且用户已经看见UI更新后，才会调用该回调，所以是异步的。
                     
                       2.每个函数组件中，可以多次使用useEffect,但是不要放进判断或循环等代码块中。
                           因为同样将需要副作用的记录记函数组件节点的表格中

                       3.useEffect的回调副作用函数，可以有返回值，返回值必须是一个函数或undefined,该返回的函数叫做清理函数。
                           1.该返回值函数 react会自动运行，运行的时间点是在每次运行副作用回调函数之前
                           2.首次渲染组件不会运行该返回值函数
                           3.useEffect所在的函数组件被销毁时一定会运行该返回值函数

                       4.useEffect函数，可以传递第二个参数
                           1.第二个参数是一个数组    会遍历该数组 用 Object.is 来判断数据是否发生变化，只要其中一个发生变化就可以
                           2.数组中记录该副作用的依赖数据
                           3.当组件重新渲染后，只有依赖数据与上一次不一样时，才会执行副作用的回调函数
                           4.所以，当传递了依赖数据后，如果数据没有发生变化
                                副作用函数仅在第一次渲染后运行
                                清理函数进行卸载组件后运行
                           5.如果没有第二个参数，则该组件每次刷新时都会执行副作用回调
                       
                       5.副作用函数中，如果使用了函数上下文中的变量，则由于闭包的影响,会导致副作用函数中变量不会实时变化。

                       6.副作用函数在每次注册时，会覆盖掉之前的副作用函数，因此，尽量保持副作用函数的稳定，否则控制起来比较复杂。
                             函数的功能尽量保持相同 
                          
         
        
        */
    </script>
    <script src="https://unpkg.com/react@16/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@16/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
    <script src="https://unpkg.com/prop-types@15.6/prop-types.min.js"></script>
    <script src="./index.jsx" type="text/babel"></script>
    <!-- <script src="./index6.jsx" type="text/babel"></script> -->
    <!-- <script src="./index5.jsx" type="text/babel"></script> -->
    <!-- <script src="./index4.jsx" type="text/babel"></script> -->
    <!-- <script src="./index3.jsx" type="text/babel"></script> -->
    <!-- <script src="./index2.jsx" type="text/babel"></script> -->
    <!-- <script src="./index1.jsx" type="text/babel"></script> -->
    <!-- <script src="./index.jsx" type="text/babel"></script> -->
    <script type="text/babel">
            const root = document.getElementById('root');

            const useState = React.useState;
            const useEffect = React.useEffect;


            ReactDOM.render((<App/>),root);
    
    </script>
</body>
</html>