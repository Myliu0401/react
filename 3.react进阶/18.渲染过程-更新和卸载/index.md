### 更新节点

   更新的场景：
   1. 重新调用`ReactDOM.render`函数，触发根节点的更新
   2. 在类组件的实例对象中调用`setState`,会导致该实例所在的节点更新
   3. 在函数组件中调用 `useState` hook 的 返回函数,会导致该函数组件的节点更新

   节点更新：
   1. 如果调用的是`ReactDOM.render`,将进入根节点的对比（diff）更新
   2. 如果调用的是`setState`:
      1. 运行生命周期函数 `static getDerivedStateFromProps`
      2. 运行生命周期函数 `shouldComponentUpdate` ,如果该函数返回 false，那么将终止当前流程。
      3. 运行`render`函数，得到一个新的节点，进入该新的节点的**对比更新**
      4. 将生命周期函数`getSnapshotBeforeUpdate`加入执行队列中，以待将来执行
      5. 将生命周期函数`componentDidUpdate`,加入执行队列中，以待将来执行

   后续步骤：
   1. 更新虚拟DOM树
   2. 完成真实DOM的更新
   3. 依次调用队列中的`componentDidMount`
   4. 依次调用队列中的`getSnapshotBeforeUpdate`
   5. 依次调用队列中的`componentDidUpdate`


### 对比更新(diff)

  将产生的新节点，对比之前虚拟dom中的节点，发现差异完成更新

  问题：对比之前虚拟dom树中的那个节点
       如果给节点设置唯一标识，那么需要对整颗虚拟dom树递归遍历进行对比唯一标识，才能得到对应的旧节点，但是太耗效率了。
  
  React为了提高对比效率，做出了以下假设：
  1. 假设节点不会出现层次的移动 
     如：在第三层上的节点不会跑到第一层上去
     这样对比时，直接找到旧树对应位置的节点进行对比 
     当调用`setState`或`useState`的返回函数，就可以知道该节点的深度在哪里。
  2. 不同的节点类型会产生不同的结构
     1. 相同的节点类型：节点本身的类型相同，如果是有React元素生成的，type值还必须一致
     2. 其他的，都属于不同的节点类型
  3. 多个同类型的兄弟节点通过唯一标识，**key**来确定对比新节点
   
  **key**的作用：用于通过旧节点，寻找对应的新节点，如果旧节点有key，则更新时，会寻找同层级中相同的key值的节点，进行对比更新。
                （如果没有找到，这进入没有找到对比目标，如果找到，则进行对比目标节点的流程）
  **key**应该在相同范围内唯一，并且保持稳定

#### 找到了对比目标节点
   1. 判断节点类型是否一致
      一致，根据不同的节点类型做不同的事：
      1. 空节点： 什么都不做
      2. DOM节点： 
         1. 直接重用之前的真实DOM对象
         2. 将其属性变化记录下来，以待将来统一完成更新（现在不会真正的更新）
         3. 遍历该新的React元素的子元素，**递归对比更新**
      3. 文本节点：
         1. 直接重用之前的真实DOM对象
         2. 将新文本的变化记录下来，以待将来统一完成更新
      4. 函数组件节点： 调用该函数组件，得到一个新的节点对象  进行 **递归遍历对比流程**
      5. 类组件节点： 
         1. 重用之前的实例
         2. 调用该实例的生命周期方法 `static getDerivedStateFromProps`
         3. 调用该实例的生命周期方法 `shouldComponentUpdate` 如果返回 false 将终止流程
         4. 运行`render`函数，得到一个新的节点对象，进行 **递归对比更新流程**
         5. 将该实例的`getSnapshotBeforeUpdate`函数，加入到执行队列
         6. 将该实例的`componentDidUpdate`函数，加入到执行队列
      6. 数组节点：遍历数组进行 **递归对比更新**

      不一致：整体上卸载旧的节点，全新创建新的节点
      1. 创建新的节点：进入新节点的挂载流程
      2. 卸载旧的节点：
         1. 如果是 文本节点 空节点 数组节点 函数节点 那么直接放弃该节点
             1. 如果该节点有子节点的话，递归卸载子节点
             2. 如果函数组件用使用hook的话，根据hook来执行对应的函数
         2. 如果是类组件节点：
             1. 直接放弃该节点
             2. 递归卸载子节点 并调用节点的`componentWillUnMount`函数
   

#### 没有找到对比目标
  1. 卸载多余的旧节点 （卸载旧节点的流程）
  2. 创建新加入的节点 （新节点的挂载流程）
      
  


   
