<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        /* 
               Redux核心概念
                  action（分发）   reducer（处理器）   store（仓库）
                  
            
               MVC
                 它是一个UI的解决方案，用于降低UI，以及UI关联的数据的复杂度

               传统的服务端的MVC
                  环境： 
                     1.服务端需要响应一个完整的HTML 
                     2.该HTML中包含页面需要的数据
                     3.浏览器仅承担渲染页面的作用
                  这种方式叫做服务端渲染，即服务端将完整的页面组装好之后，一起发送给客户端，
                  服务端需要处理UI中要用到的数据，并且要将数据嵌入到页面中，最终生成一个完整的HTML页面传给客户端。
                  为了降低处理这个过程的复杂度，出现了MVC模式。

                  controller:处理请求，组装这次请求需要的数据。 (controller控制器)
                  model:需要用于UI渲染的数据模型 如：一个数组
                  view:视图，用于将模型组装到界面中

                  前端发起请求 服务器根据请求路径进行处理 由控制器进行处理，生成数据模型model,交给view进行视图的拼装，最后变成一个完整的HTML相应给客户端
 
             
               前端MVC模式的困难
                 react解决了 数据->视图 的问题，相当于根据数据渲染视图

                 1.前端的（控制器controller）要比服务器复杂很多，因为前端中的controller要处理的是用户的操作，而用户的操作场景是复杂的。
                    前端的控制器就相当于 事件处理程序，而用户有可能 点击、移入、移出等等，功能要处理，如果再加上处理数据那么会变得非常臃肿复杂。
                    同时处理了事件响应 和 业务逻辑。这不符合单一职责。
                
                 2.对于那些组件化的框架 如：vue、react 它们使用的是单向数据流，若需要共享数据，则必须将数据提升到顶层组件，然后数据再一层一层传递，极其繁琐。
                   虽然可以使用上下文来提供共享数据，但对数据的操作难以监控，容易导致调试出错，以及数据还原的困难。并且，若开发一个大中型项目，共享的数据很多，会导致上下文中的数据变得非常复杂。


               前端需要一个独立的数据解决方案
                  flux:由facebook提出的数据解决方案，引入action的概念
                  action是一个普通的对象，用于描述要干什么。 **action是触发数据变化的唯一原因**
                   如： 一个action对象
                       {
                          type:'xxx',  //要干嘛
                          payload:{  //负荷

                          }
                       }

                  store表示数据仓库，用于存储共享数据，还可以根据不同的action更改仓库中数据，但是如果数据太多，所有更改数据都在store中进行更改，又会变成臃肿。

                  redux
                     在flux基础上，引入了reducer的概念
                     reducer:处理器，用于根据action来处理数据，处理后的数据会被仓库重新保存

                   最终由 action ---分发---》数据仓库store ---将action传递给---》reducer 进行处理后 ---》传给数据仓库进行保存

        
        
        
        
        
        
        */
    </script>
</body>
</html>